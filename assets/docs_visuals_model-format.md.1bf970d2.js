import{_ as e,c as t,o as a,d as i}from"./app.aa7b13f3.js";const o="/assets/example.b4e28843.png",f=JSON.parse('{"title":"Model Format","description":"","frontmatter":{},"headers":[{"level":3,"title":"Importing Models","slug":"importing-models","link":"#importing-models","children":[]},{"level":3,"title":"Setting Up for Blender","slug":"setting-up-for-blender","link":"#setting-up-for-blender","children":[]},{"level":3,"title":"Understanding the Format","slug":"understanding-the-format","link":"#understanding-the-format","children":[]},{"level":3,"title":"Placeholder Empties","slug":"placeholder-empties","link":"#placeholder-empties","children":[]},{"level":3,"title":"Unused Empties","slug":"unused-empties","link":"#unused-empties","children":[]},{"level":2,"title":"Known Empties","slug":"known-empties","link":"#known-empties","children":[{"level":3,"title":"icon_camera","slug":"icon-camera","link":"#icon-camera","children":[]},{"level":3,"title":"pathNode","slug":"pathnode","link":"#pathnode","children":[]},{"level":3,"title":"bounding_radius","slug":"bounding-radius","link":"#bounding-radius","children":[]},{"level":3,"title":"placeCollide","slug":"placecollide","link":"#placecollide","children":[]},{"level":3,"title":"static and dynamic primitives","slug":"static-and-dynamic-primitives","link":"#static-and-dynamic-primitives","children":[]},{"level":3,"title":"rayTestLimits & Others","slug":"raytestlimits-others","link":"#raytestlimits-others","children":[]}]}],"relativePath":"docs/visuals/model-format.md","lastUpdated":1664014405000}'),n={name:"docs/visuals/model-format.md"},r=i('<h1 id="model-format" tabindex="-1">Model Format <a class="header-anchor" href="#model-format" aria-hidden="true">#</a></h1><h3 id="importing-models" tabindex="-1">Importing Models <a class="header-anchor" href="#importing-models" aria-hidden="true">#</a></h3><p>In Sapiens, <code>.glb</code> models can be found inside of <code>GameResources/models</code>. These can be imported into blender using <code>file -&gt; import -&gt; glTF 2.0</code>.</p><h3 id="setting-up-for-blender" tabindex="-1">Setting Up for Blender <a class="header-anchor" href="#setting-up-for-blender" aria-hidden="true">#</a></h3><p>You need to do this or your model won&#39;t scale correctly. Make sure that you set the scale type to <code>Quaternion (WXYZ)</code> under Object Properties. When you want to scale your model make sure to use <code>Ctrl + A</code> and select apply all transforms.</p><h3 id="understanding-the-format" tabindex="-1">Understanding the Format <a class="header-anchor" href="#understanding-the-format" aria-hidden="true">#</a></h3><p>Sapiens models are generally made up of standard geometry, paired with &#39;meta data&#39;, represented via empties. You can <a href="/docs/visuals/materials.html">learn how materials work here.</a>.</p><p><img src="'+o+'" alt=""></p><h3 id="placeholder-empties" tabindex="-1">Placeholder Empties <a class="header-anchor" href="#placeholder-empties" aria-hidden="true">#</a></h3><p>Some empties are per-model, and are used directly by dave for logic. They aren&#39;t required for all models!</p><p>For example, <code>coconutTree</code> contains empties <code>coconut_1</code> through <code>coconut_4</code>. These are used to position the <code>coconut</code> model in-game.</p><p>This kind of logic is usually paired with something written into the <code>modelPlaceholder</code>, so you can look there for inspiration.</p><h3 id="unused-empties" tabindex="-1">Unused Empties <a class="header-anchor" href="#unused-empties" aria-hidden="true">#</a></h3><p>The &quot;Camera&quot; and &quot;Lamp&quot; objects are just default Blender things that dave tends to leave in there, as they don&#39;t do any harm.</p><h2 id="known-empties" tabindex="-1">Known Empties <a class="header-anchor" href="#known-empties" aria-hidden="true">#</a></h2><p>This section will explain a list of known empties, and their effects.</p><h3 id="icon-camera" tabindex="-1">icon_camera <a class="header-anchor" href="#icon-camera" aria-hidden="true">#</a></h3><p>Used to render the icon.</p><h3 id="pathnode" tabindex="-1">pathNode <a class="header-anchor" href="#pathnode" aria-hidden="true">#</a></h3><p>`pathNode`` primitives are extra nodes that are added to the pathfinding. They are especially important for doorways, as otherwise it&#39;s unlikely that sapiens will happen to find nodes that go through the gap. They&#39;re also added at corners, and on walkable surfaces like floors and steps. The engine doesn&#39;t actually place nodes in those locations directly, as the ground might be uneaven, but it casts rays through those positions, to try to find a ground position for the pathfinding.</p><h3 id="bounding-radius" tabindex="-1">bounding_radius <a class="header-anchor" href="#bounding-radius" aria-hidden="true">#</a></h3><p>This empty is used to provide a bounding box for your model. Semantics are unknown.</p><h3 id="placecollide" tabindex="-1">placeCollide <a class="header-anchor" href="#placecollide" aria-hidden="true">#</a></h3><p>`placeCollide`` primitives are used when placing the object in build mode or planting/decorating, to ensure there are no collisions, eg to stop you placing 100 plants in the same spot.</p><h3 id="static-and-dynamic-primitives" tabindex="-1">static and dynamic primitives <a class="header-anchor" href="#static-and-dynamic-primitives" aria-hidden="true">#</a></h3><p><code>static`` primitives are used in the physics when the objects are static, and also for other purposes, but can&#39;t remember all of them off the top of my head. </code>dynamic` primitives are for when the object is loose and falling. I think the idea was that the static ones would be more complex, but in practice they are usually the same.</p><h3 id="raytestlimits-others" tabindex="-1">rayTestLimits &amp; Others <a class="header-anchor" href="#raytestlimits-others" aria-hidden="true">#</a></h3><p>And there are <code>rayTest`` limits, </code>lookat`` boxes and a few other things I&#39;m not even really sure of anymore. They are various hacks mostly for optimizations. Like the coconut tree because it is so tall and thin causes performance problems when you are looking through them, as once it hits the bounding radius, it checks every triangle. So the ray test limits reduce that.</p>',28),s=[r];function d(l,h,c,p,m,u){return a(),t("div",null,s)}const y=e(n,[["render",d]]);export{f as __pageData,y as default};
