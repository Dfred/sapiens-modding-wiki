import{_ as e,c as a,o as t,d as r}from"./app.7a3810d5.js";const g=JSON.parse('{"title":"Thread Management","description":"","frontmatter":{},"headers":[{"level":2,"title":"Available Threads","slug":"available-threads","link":"#available-threads","children":[{"level":3,"title":"mainThread","slug":"mainthread","link":"#mainthread","children":[]},{"level":3,"title":"logicThread","slug":"logicthread","link":"#logicthread","children":[]},{"level":3,"title":"server","slug":"server","link":"#server","children":[]},{"level":3,"title":"Common Folder","slug":"common-folder","link":"#common-folder","children":[]},{"level":3,"title":"misc. Threads","slug":"misc-threads","link":"#misc-threads","children":[]}]},{"level":2,"title":"Thread Communication","slug":"thread-communication","link":"#thread-communication","children":[{"level":3,"title":"Client to Server","slug":"client-to-server","link":"#client-to-server","children":[]},{"level":3,"title":"Server to Client","slug":"server-to-client","link":"#server-to-client","children":[]}]}],"relativePath":"docs/scripting/thread-management.md","lastUpdated":1664014405000}'),i={name:"docs/scripting/thread-management.md"},n=r('<h1 id="thread-management" tabindex="-1">Thread Management <a class="header-anchor" href="#thread-management" aria-hidden="true">#</a></h1><p>Sapiens uses multiple threads to manage tasks. These threads are more or less reflected in the folder structure of the Lua code. For example, code nested within <code>server</code> will only be executed on the server, and so forth.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Although Sapiens is currently singleplayer, the actual game is programmed as a multiplayer experience, where the server thread is intended to run on a dedicated server box, with clients connecting.</p></div><h2 id="available-threads" tabindex="-1">Available Threads <a class="header-anchor" href="#available-threads" aria-hidden="true">#</a></h2><p>Here is a quick explanation of all threads.</p><h3 id="mainthread" tabindex="-1">mainThread <a class="header-anchor" href="#mainthread" aria-hidden="true">#</a></h3><p>The <code>mainThread</code> does the rendering, handles UI, player movement, anything that needs immediate feedback to the user. You can think of the <code>mainThread</code> as the client.</p><h3 id="logicthread" tabindex="-1">logicThread <a class="header-anchor" href="#logicthread" aria-hidden="true">#</a></h3><p>The <code>logicThread</code> is a secondary client-side thread, which handles handles everything else on the client, generating terrain, updating buffers for rendering, updating animations, communications with the server.</p><h3 id="server" tabindex="-1">server <a class="header-anchor" href="#server" aria-hidden="true">#</a></h3><p>The <code>server</code> thread runs the client-agnostic logic. It may help to think of Sapiens is a multiplayer game, where multiple clients can attach to the same server.</p><p>For example, if a client digs out a section of the world, this will need to be communicated to all clients. This will be done via the server.</p><h3 id="common-folder" tabindex="-1">Common Folder <a class="header-anchor" href="#common-folder" aria-hidden="true">#</a></h3><p>The &#39;common&#39; folder in Sapiens contains a collection of files that can be accessed from multiple threads.</p><h3 id="misc-threads" tabindex="-1">misc. Threads <a class="header-anchor" href="#misc-threads" aria-hidden="true">#</a></h3><p>Alongside these main threads, there is also a host of other threads, doing various small tasks. These can range from world generation, to pathfinding, to particle rendering.</p><h2 id="thread-communication" tabindex="-1">Thread Communication <a class="header-anchor" href="#thread-communication" aria-hidden="true">#</a></h2><p>Sapiens has an RPC-like structure for elevating client calls to the server, and for server calls to be multicast to the clients. The only supported way to communicate between threads is the callMainThreadFunction/registerMainThreadFunction types of methods.</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>You can only send one param at once! Use a table if you must process multiple pieces of information at once.</p></div><h3 id="client-to-server" tabindex="-1">Client to Server <a class="header-anchor" href="#client-to-server" aria-hidden="true">#</a></h3><p>To communicate for the client to the server, you will need to register a new net function (at startup), then call it.</p><ul><li><code>server:registerNetFunction</code> can be called on the <code>server</code> to make a server function available to the <code>mainThread</code>.</li><li><code>logicInterface:callServerFunction</code> can be called on the <code>mainThread</code> to fire a function on the <code>server</code>, assuming <code>registerNetFunction</code> is setup.</li></ul><h3 id="server-to-client" tabindex="-1">Server to Client <a class="header-anchor" href="#server-to-client" aria-hidden="true">#</a></h3><p>To communicate from the Server to the Client, you will need to do a bit of setup. Unless I am mistaken, the path is: Server -&gt; Logic -&gt; MainThread</p><ul><li><code>logic:registerLogicThreadNetFunction</code> can be used to register a <code>logic</code> thread function as callable on the server.</li><li><code>logicInterface:registerMainThreadFunction</code> can be used to register a <code>mainThread</code> function as callable on the logic thread.</li></ul><p>And then finally, you can use:</p><ul><li><code>server:callClientFunction</code> can be called on the <code>server</code> to propagate a server call to the <code>mainThread</code>, via the <code>logic</code> thread.</li></ul><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>Lua objects need to be serialized/unserialized when those methods are called, and that can be a performance bottleneck if abused too much</p></div>',28),o=[n];function l(c,d,s,h,m,u){return t(),a("div",null,o)}const v=e(i,[["render",l]]);export{g as __pageData,v as default};
